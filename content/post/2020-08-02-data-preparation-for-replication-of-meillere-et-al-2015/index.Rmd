---
title: Data Preparation for Replication of Meillere et al. (2015)
author: Nathan Brouwer
date: '2020-10-02'
slug: data-preparation-for-replication-of-meillere-et-al-2015
categories: []
tags: 
  - R
math: no
meta: no
toc: no
---


<!--more-->

## Packages

```{r setup}
library(sparrowtelomeres)
library(readxl)
library(reshape2)
```

TODO: extract some raw data directly from website?

## Raw data

The raw data is available via the publisher's website (https://royalsocietypublishing.org/doi/suppl/10.1098/rsbl.2015.0559) in a table in a word document called "rsbl20150559supp1.docx".  This file is saved in the folder /inst/extdata.

Data tables can be extracted directly from Word documents using
docxtractr::docx_extract_all_tbls()

(This code would set up the file name; however, I didn't follow through this this)
```{r, eval = F}
file.name <- "rsbl20150559supp1.docx"
file.full <- here::here("/inst/exdata", file.name)
```


Data was copied and pasted from the Word document into an Excel spreadsheet into a sheet called "orig".

Set up the file name
```{r, eval = F}
file.name <- "Meillere_et_al_2015_telomere_data.xlsx"
file.full <- here::here("inst/extdata",file.name)
```

Read in the datasheet
```{r, eval = F}
dat.orig <- readxl::read_xlsx(file.full,sheet = "orig")
```

## Clean data

```{r, eval = F}
head(dat.orig)
summary(dat.orig)
summary(factor(dat.orig$sex))
```

## Set factors

```{r, eval = F}
dat.orig$nest <- as.factor(dat.orig$nest)
dat.orig$treatment <- as.factor(dat.orig$treatment)
dat.orig$sex <- as.factor(dat.orig$sex)
dat.orig$fledging <- as.factor(dat.orig$fledging)
```

## Rename object

Give it a useful name

```{r, eval = F}
telosfull <- dat.orig
```


Save as data .rda object (only run during original package creati0on)
```{r, eval = F}
# usethis::use_data(telosfull, overwrite = T)
```

Save as .csv

 (only run during original package creati0on)
```{r, eval = F}
#file.full <- here::here("/inst/extdata","telosfull.csv")
#write.csv(telosfull, file.full, row.names = F)
```


## Fledging success data

The authors used a binomial glm using the number of fledged per nest for fledging success models.

Note: in the data provided, fledging success appears to be recorded at the brood level, even though in methods they report modeling the propotion of nestling fledged, which implies nestling-level data.

```{r, eval = F}
#reshape data
telosfull[,c("nest","fledging")]
fledgedata <- reshape2::dcast(data = telosfull,
      formula = nest + treatment ~  fledging)

#rename columns
names(fledgedata)[3:4] <- c("fledged.no","fledged.yes")

#calculate total number of fledglings in brood
## see note above about nest-level success
fledgedata$brood.size <- fledgedata$fledged.no + fledgedata$fledged.yes

# code nest as successful or not
fledgedata$nest.success <- ifelse(fledgedata$fledged.yes > 0, 1, 0)

#create data object
#(only run during original package creation)
#usethis::use_data(fledgedata, overwrite = T)

#create .csv
#(only run during original package creation)
#file.full <- here::here("/inst/extdata","fledgedata.csv")
#write.csv(fledgedata,file.full, row.names = F)
```


## Subset data

```{r}
dat.orig$index <- 1:nrow(dat.orig)
group.IDS <-unique(dat.orig$nest)
length(group.IDS)

N.reps <- 1000
unique.indices <- matrix(NA, nrow = N.reps, 
                         ncol =length(group.IDS)+1)

colnames(unique.indices)<- c("p.value",group.IDS)
head(unique.indices)

for(j in 1:nrow(unique.indices)){
  
dat.orig$for.subset <- "no"
# generate random data
for(i in 1:length(unique.IDs)){
  group.ID.i <- group.IDS[i]
  i.group.i <- which(dat.orig$nest == group.ID.i)
  
  if(length(i.group.i) == 1){
   dat.orig$for.subset[i.group.i] <- "YES"
    next
  }
  i.sampled <- sample(x = i.group.i, size = 1, replace = F)
  dat.orig$for.subset[i.sampled]<-"YES"
}


#subset random data
length(subset.i)
subset.i <- which(dat.orig$for.subset == "YES")
unique.indices[j,-1] <- subset.i

dat.subset <- dat.orig[subset.i,]

#runt-test on random sample
t.out <- t.test(telomere.length ~ treatment, 
       data = dat.subset)

t.out$p.value
unique.indices[j,1] <- t.out$p.value

}



```

```{r}
head(unique.indices)
dim(unique.indices)


duplicated.i <- which(duplicated(unique.indices[,1]) == FALSE)
length(duplicated.i)

unique.indices <- unique.indices[duplicated.i,]
dim(unique.indices)
hist(log(unique.indices[,1]))
abline(v = log(0.05))

p0.05 <- which(unique.indices[,1] < 0.05)

unique.indices.p.05 <- unique.indices[p0.05, ]
index.p.0.5_1 <- unique.indices.p.05[1,-1]


dat_p.0.5_1 <- dat.orig[index.p.0.5,]

t.test(telomere.length ~ treatment, 
       data = dat_p.0.5_1)


```

```{r}
#dat.subset.p.0.03824022<- dat.subset
#dat.subset.p.0.043369<- dat.subset
#dat.subset.p.0.05120778 <- dat.subset
#dat.subset.p.0.048 <- dat.subset
#dat.subset.p.0.051 <- dat.subset
```

